虽然理论上所有的递归都可以用迭代来实现，但是有的场景难度可能比较大。
例如：都知道回溯法其实就是递归，但是很少人用迭代的方式去实现回溯算法！
因为对于回溯算法已经是非常复杂的递归了，如果在用迭代的话，就是自己给自己找麻烦，效率也并不一定高。

可以出一道面试题：栈里面的元素在内存中是连续分布的么？
这个问题有两个陷阱：
陷阱1：栈是容器适配器，底层容器使用不同的容器，导致栈内数据在内存中是不是连续分布。
陷阱2：缺省情况下，默认底层容器是deque，那么deque的在内存中的数据分布是什么样的呢？ 答案是：不连续的，下文也会提到deque。

一个队列在模拟栈弹出元素的时候只要将队列头部的元素（除了最后一个元素外） 重新添加到队列尾部，此时在去弹出元素就是栈的顺序了

递归的实现就是：每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中，然后递归返回的时候，从栈顶弹出上一次递归的各项参数，所以这就是递归为什么可以返回上一层位置的原因。

724寻找数组中心下标, rightSum = sum - leftSum + nums[i]; 并不是因为多减了nums[i], 是因为按照左右和的定义, leftSum多加了nums[i](实际上加到i-1就好), 所以rightSum也要加上nums[i]





