https://blog.csdn.net/w20001118/article/details/125724647
Java基础:
equlas是Object类的方法，本质上与==一样，但是有些类重写了equals方法，比如String的equals被重写后，比较的是内存地址，另外重写了equlas后，也必须重写hashcode()方法

HashMap在Jdk1.8以后是基于数组+链表+红黑树来实现的
HashMap的默认容量为16，默认的负载因子为0.75，当HashMap中元素个数超过容量乘以负载因子的个数时，就创建一个大小为前一次两倍的新数组，再将原来数组中的数据复制到新数组中。当数组长度到达64且链表长度大于8时，链表转为红黑树
计算key的hash值，然后进行二次hash，根据二次hash(扰动函数, 减少hash碰撞)结果找到对应的索引位置

ConcurrentHashMap采用CAS+Synchronized保证线程安全，每次插入数据时判断在当前数组下标是否是第一次插入，是就通过CAS方式插入，然后判断f.hash是否=-1，是的话就说明其他线程正在进行扩容，当前线程也会参与扩容；删除方法用了synchronized修饰，保证并发下移除元素安全

ArratList的底层使用动态数组，默认容量为10，当元素数量到达容量时，生成一个新的数组，大小为前一次的1.5倍，然后将原来的数组copy过来
使用juc下的CopyOnWriterArrayList，该类实现了读操作不加锁，写操作时为list创建一个副本，期间其它线程读取的都是原本list，写操作都在副本中进行，写入完成后，再将指针指向副本。


Java多线程:
死锁指多个线程在执行过程中，因争夺资源造成的一种相互等待的僵局. 死锁的必要条件:
互斥条件：同一资源同时只能由一个线程读取
不可抢占条件：不能强行剥夺线程占有的资源
请求和保持条件：请求其他资源的同时对自己手中的资源保持不放
循环等待条件：在相互等待资源的过程中，形成一个闭环
想要预防死锁，只需要破坏其中一个条件即可，银行家算法可以预防死锁

保证并发安全的三大特性
原子性：一次或多次操作在执行期间不被其他线程影响
可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道
有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排

volatile保证变量的可见性和有序性，不保证原子性。使用了 volatile 修饰变量后，在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。
单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：申请内存空间，将内存空间引用赋值给变量，变量初始化。如果不禁止重排序，有可能得到一个未经初始化的变量。

ThreadLocal原理是为每个线程创建变量副本，不同线程之间不可见，保证线程安全。每个线程内部都维护了一个Map，key为threadLocal实例，value为要保存的副本。
但是使用ThreadLocal会存在内存泄露问题，因为key为弱引用，而value为强引用，每次gc时key都会回收，而value不会被回收。所以为了解决内存泄漏问题，可以在每次使用完后删除value或者使用static修饰ThreadLocal，可以随时获取value

CAS锁可以保证原子性，思想是更新内存时会判断内存值是否被别人修改过，如果没有就直接更新。如果被修改，就重新获取值，直到更新完成为止。这样的缺点是
（1）只能支持一个变量的原子操作，不能保证整个代码块的原子操作 
（2）CAS频繁失败导致CPU开销大
（3）ABA问题:线程1和线程2同时去修改一个变量，将值从A改为B，但线程1突然阻塞，此时线程2将A改为B,然后线程3又将B改成A,此时线程1将A又改为B,这个过程线程2是不知道的，这就是ABA问题，可以通过版本号或时间戳解决

synchronized锁原理和优化
synchronized是通过对象头的Mark Word来表明监视器(Monitor)的, 监视器本质是依赖操作系统的互斥锁实现的. 操作系统实现线程切换要从用户态切换为核心态, 成本很高, 此时这种锁叫重量级锁, 在JDK1.6以后引入了偏向锁、轻量级锁、重量级锁
偏向锁：当一段代码没有别的线程访问，此时线程去访问会直接获取偏向锁
轻量级锁：当锁是偏向锁时，有另外一个线程来访问，偏向锁会升级为轻量级锁，这个线程会通过自旋方式不断获取锁，不会阻塞，提高性能
重量级锁：轻量级锁自旋一段时间后线程还没有获取到锁，线程就会进入阻塞状态，该锁会升级为重量级锁，重量级锁时，来竞争锁的所有线程都会阻塞，性能降低
注意，锁只能升级不能降级

JUC常用辅助类CountDownLatch:设定一个数，当调用CountDown()时数量减一，当调用await() 时判断计数器是否为0，不为0就阻塞，直到计数器为0
CyclicBarrier：设定一个数,当调用await() 时判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值
Semaphore:设定一个信号量，当调用acquire()时判断是否还有信号，有就信号量减一线程继续执行，没有就阻塞等待其他线程释放信号量，当调用release()时释放信号量，

如何根据 CPU 核心数设计线程池线程数量
IO密集型：最佳线程数 = CPU核心数 * (1/CPU利用率) = CPU核心数 * (1 + (I/O耗时/CPU耗时)), 极限情况下为CPU核心数 * 2
计算密集型：CPU核心数 + 1
为什么加 1？即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费。


JVM:
JVM运行时数据区（内存结构）
线程私有区：
（1）虚拟机栈：每次调用方法都会在虚拟机栈中产生一个栈帧，每个栈帧中都有方法的参数、局部变量、方法出口等信息，方法执行完毕后释放栈帧
（2）本地方法栈：为native修饰的本地方法提供的空间，在HotSpot中与虚拟机合二为一
（3）程序计数器：保存指令执行的地址，方便线程切回后能继续执行代码
线程共享区：
（4）堆内存：Jvm进行垃圾回收的主要区域，存放对象信息，分为新生代和老年代
（5）方法区：存放类信息、静态变量、常量、运行时常量池等信息。JDK1.8之前用持久代实现，JDK1.8后用元空间实现，元空间使用的是本地内存，而非在JVM内存结构中

什么情况下会内存溢出？
堆内存溢出：（1）当对象一直创建而不被回收时（2）加载的类越来越多时（3)虚拟机栈的线程越来越多时
栈溢出：方法调用次数过多，一般是递归不当造成

JVM有哪些垃圾回收算法？
（1）标记清除算法： 标记不需要回收的对象，然后清除没有标记的对象，会造成许多内存碎片。
（2）复制算法： 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。用在新生代
（3）标记整理算法： 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。用在老年代

GC如何判断对象可以被回收？
（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题
（2）可达性分析法：从GCRoot开始往下搜索，搜索过的路径称为引用链，若一个对象GCRoot没有任何的引用链，则判定可以回收
GCRoot有：虚拟机栈中引用的对象，方法区中静态变量引用的对象，本地方法栈中引用的对象

类加载过程
（1）加载 ：加载字节码文件，将字节码中的静态变量和常量转换到方法区中，在堆中生成class对象作为方法区入口
（2）连接：
	验证：验证字节码文件的正确性。
	准备：正式为类变量在方法区中分配内存，并设置初始值。
	解析：将符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址）。
（3）初始化 ：执行类构造器（不是常规的构造方法），为静态变量赋初值并初始化静态代码块。

对象头中有两部分，一部分是MarkWork,存储对象运行时的数据，如GC分代年龄、GC标记、锁的状态、线程ID等；另外一部分是指向对象类型的指针，如果是数组，还有一个部分存放数组长度

JVM类初始化顺序
父类静态代码块和静态成员变量->子类静态代码块和静态成员变量->父类代码块和普通成员变量->父类构造方法->子类代码块和普成员变量->子类构造方法


MySQL基础:
SQL编写顺序
select distinct  显示字段
from 表名 
join 要连接的表名 on 连接查询条件
where 约束条件
group by 分组字段 having 分组过滤条件
order By AESC（降序）或ASC（默认升序）
limit 分页

SQL执行优先级
from 表名
on 连接查询条件
join 要连接的表名
where 约束条件
group by 分组内容
having 过滤条件
select 显示字段
distinct 去重字段
order By AESC（降序）或ASC（升序）
limit 分页

mysql事务特性
原子性：一个事务内的操作统一成功或失败
一致性：事务前后的数据总量不变
隔离性：事务与事务之间相互不影响
持久性：事务一旦提交发生的改变不可逆

事务靠什么保证
原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql
一致性：由其他三大特性共同保证，是事务的目的
隔离性：由MVCC保证
持久性：由redolog日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复

MVCC（Multi-Version Concurrency Control）即多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。MVCC使得大部分支持行锁的事务引擎，不再单纯的使用行锁来进行数据库的并发控制，取而代之的是把数据库的行锁与行的多个版本结合起来，只需要很小的开销，就可以实现非锁定读，从而大大提高数据库系统的并发性能。
MVCC是多版本并发控制，为每次事务生成一个新版本数据，每个事务都由自己的版本，从而不加锁就决绝读写冲突，这种读叫做快照读。只在读已提交和可重复读中生效。
实现原理由四个东西保证，他们是
undolog日志：记录了数据历史版本
readView:事务进行快照读时产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见
隐藏字段DB_TRC_ID： 最近修改记录的事务ID 
隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本

事务的隔离级别
在高并发情况下，并发事务会产生脏读、不可重复读、幻读问题，这时需要用隔离级别来控制
读未提交：最低的隔离级别，允许读取尚未提交的数据变更，可能造成脏读、不可重复读、幻读。
读提交：允许读取并发事务已经提交的数据，可以避免脏读，但是可能造成不可重复、幻读。
可重复读：对同一字段多次读取的结果都是一致的，除非本身事务修改，可以避免脏读和不可重复读，但是可能造成幻读。
可串行化：最高的隔离级别，完全服从ACID的隔离级别，所以的事务依次执行，可以避免脏读、不可重复读、幻读。
InnoDB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过间隙锁解决了幻读问题。

什么是快照读和当前读
*快照读读取的是当前数据的可见版本，可能是会过期数据，不加锁的select就是快照读
*当前读读取的是数据的最新版本，并且当前读返回的记录都会上锁，保证其他事务不会并发修改这条记录。如update、insert、delete、select for undate（排他锁）、select lockin share mode（共享锁） 都是当前读

MySQL有哪些索引
主键索引：一张表只能有一个主键索引，主键索引列不能有空值和重复值
唯一索引：唯一索引不能有相同值，但允许为空
普通索引：允许出现重复值
组合索引：对多个字段建立一个联合索引，减少索引开销，遵循最左匹配原则
全文索引：myisam引擎支持，通过建立倒排索引提升检索效率，广泛用于搜索引擎

B和B+数的区别，为什么使用B+数
二叉树：索引字段有序，极端情况会变成链表形式
AVL数：树的高度不可控
B数：控制了树的高度，但是索引值和data都分布在每个具体的节点当中，若要进行范围查询，要进行多次回溯，IO开销大
B+树：非叶子节点只存储索引值，叶子节点再存储索引+具体数据，从小到大用链表连接在一起，范围查询可直接遍历不需要回溯

MySQL有哪些锁
基于粒度：
	*表级锁：对整张表加锁，粒度大并发小
	*行级锁：对行加锁，粒度小并发大
	*间隙锁：间隙锁，锁住表的一个区间，间隙锁之间不会冲突只在可重复读下才生效，解决了幻读
基于属性：
    *共享锁：又称读锁，一个事务为表加了读锁，其它事务只能加读锁，不能加写锁
    *排他锁：又称写锁，一个事务加写锁之后，其他事务不能再加任何锁，避免脏读问题
	
MySQL如果做慢查询优化
（1）分析sql语句，是否加载了不需要的数据列
（2）分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引
（3）表中数据是否太大，是不是要分库分表

哪些情况索引会失效
（1）where条件中有or，除非所有查询条件都有索引，否则失效
（2）like查询用%开头，索引失效
（3）索引列参与计算，索引失效
（4）违背最左匹配原则，索引失效
（5）索引字段发生类型转换，索引失效
（6）mysql觉得全表扫描更快时（数据少）

drop, truncate, delete区别


Spring:





















